<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>STEVEN&#39;S BLOG</title>
  <subtitle>my blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-06T07:41:35.575Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Steven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>My New Post</title>
    <link href="http://yoursite.com/2016/04/06/My-New-Post/"/>
    <id>http://yoursite.com/2016/04/06/My-New-Post/</id>
    <published>2016-04-06T07:41:35.000Z</published>
    <updated>2016-04-06T07:41:35.575Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hook详解(一)</title>
    <link href="http://yoursite.com/2016/04/05/hello-world/"/>
    <id>http://yoursite.com/2016/04/05/hello-world/</id>
    <published>2016-04-05T05:25:44.293Z</published>
    <updated>2016-04-07T11:34:48.810Z</updated>
    
    <content type="html">&lt;p&gt;写android hook网上到处都是，但是作为菜鸟的我要不看不懂原理，要不就不知道到底应该怎么使用T T，这篇文章把网上所有的都整理了一下，给自己一点参考吧。&lt;/p&gt;
&lt;p&gt;所有代码详见github。&lt;/p&gt;
&lt;h3 id=&quot;Hook-From-蒸米&quot;&gt;&lt;a href=&quot;#Hook-From-蒸米&quot; class=&quot;headerlink&quot; title=&quot;Hook From 蒸米&quot;&gt;&lt;/a&gt;Hook From &lt;a href=&quot;http://drops.wooyun.org/tips/9300&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;蒸米&lt;/a&gt;&lt;/h3&gt;&lt;h5 id=&quot;使用方法1&quot;&gt;&lt;a href=&quot;#使用方法1&quot; class=&quot;headerlink&quot; title=&quot;使用方法1:&quot;&gt;&lt;/a&gt;使用方法1:&lt;/h5&gt;&lt;p&gt;将target.c文件，hook1.c文件拷贝至jni文件夹,编写Android.mk文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE    := target
LOCAL_SRC_FILES := target.c
include $(BUILD_EXECUTABLE)
include $(CLEAR_VARS)
LOCAL_MODULE    := hook1
LOCAL_SRC_FILES := hook1.c
include $(BUILD_EXECUTABLE)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进入cmd,使用ndk-build编译，就会生成target,hook1文件。然后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb push target /data/local/tmp
adb shell
cd /data/local/tmp
chmod 777 ./target
./target
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就能看见target已经开始运行了。&lt;br&gt;然后ps得到target的进程号,再按照上面一样的方法把hook1文件拷贝至手机，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./hook1 pid             //这里的pid改成之前得到的进程号
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;既可以看到target已经被hook劫持。hook1-hook3均按此方法使用即可。&lt;/p&gt;
&lt;h5 id=&quot;hook1-输出系统调用号与参数&quot;&gt;&lt;a href=&quot;#hook1-输出系统调用号与参数&quot; class=&quot;headerlink&quot; title=&quot;#hook1 输出系统调用号与参数&quot;&gt;&lt;/a&gt;#hook1 输出系统调用号与参数&lt;/h5&gt;&lt;p&gt;首先，PTRACE_ATTACH上target进程，PTRACE_ATTACH与PTRACE_TRACEME最大的区别在于，后者并不会使子进程停止，只有在进行exec系统调用的时候才会导致子进程暂停;而ATTACH会使子进程立马暂停下来。&lt;br&gt;PTRACE_SYSCALL是使子进程继续运行，知道在它进行系统调用之前或之后再暂停下来。&lt;br&gt;所以这里在ATTACH后，立马SYSCALL使target继续运行，然后循环wait等target暂停进行劫持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;arm中系统调用由SWI实现,即软件中断(Software Interrupt),在请求系统服务时造成的中断,由SWI指令造成异常从而切入特权模式,从而允许非特权模式访问特权模式的函数.&lt;br&gt;ARM中有两种系统调用方式: OABI(old application binary interface)和EABI(extended application binary interface).见(内核源码arch/arm/kernel/entry-common.S文件).&lt;br&gt;对于OABI: 通过跟随在swi指令后的调用号来进行. 1101 1111 vvvv vvvv – SWI immed_8 (Thumb指令)格式)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;swi (#num | 0x900000) (0x900000是个magic值)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;对于EABI: 调用号存放在r7中. 1110 1111 0000 0000 (ef000000)– SWI 0 (Thumb指令格式)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;mov r7, #num
swi 0x0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以下面这个就好理解啦&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scno = ptrace(PTRACE_PEEKTEXT, pid, (void *)(regs-&amp;gt;ARM_pc - 4), NULL);//[pc-4],
if(scno == 0)
    return 0;

if (scno == 0xef000000) {
    scno = regs-&amp;gt;ARM_r7;
} else {
    if ((scno &amp;amp; 0x0ff00000) != 0x0f900000) {//关键是看是否是900000(magic值)        
    return -1;
    }
    scno &amp;amp;= 0x000fffff;
}
return scno;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;hook2-将参数字符串进行反转&quot;&gt;&lt;a href=&quot;#hook2-将参数字符串进行反转&quot; class=&quot;headerlink&quot; title=&quot;#hook2 将参数字符串进行反转&quot;&gt;&lt;/a&gt;#hook2 将参数字符串进行反转&lt;/h5&gt;&lt;p&gt;没啥好解释的。&lt;/p&gt;
&lt;h5 id=&quot;hook3-动态执行libc-so中的sleep函数&quot;&gt;&lt;a href=&quot;#hook3-动态执行libc-so中的sleep函数&quot; class=&quot;headerlink&quot; title=&quot;#hook3 动态执行libc.so中的sleep函数&quot;&gt;&lt;/a&gt;#hook3 动态执行libc.so中的sleep函数&lt;/h5&gt;&lt;p&gt;可以看到hook3在ATTACH后没有syscall或continue，直接就开始hook。&lt;br&gt;get_remote_addr，其实就是在Libc.so中有一个sleep库函数，我要计算出它在so文件中的基址，然后再加上libc.so运行时的地址即可。&lt;/p&gt;
&lt;p&gt;我在得到target的reg后，将arm_pc改成sleep函数的地址，然后setreg，再PTRACE_CONTINUE使target继续运行，那么target实际运行的就是sleep函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int stat = 0;
waitpid(pid, &amp;amp;stat, WUNTRACED);
while (stat != 0xb7f) {
    if (ptrace_continue(pid) == -1) {
        printf(&amp;quot;error\n&amp;quot;);
        return -1;
    }
    waitpid(pid, &amp;amp;stat, WUNTRACED);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;关于WUNTRACED&quot;&gt;&lt;a href=&quot;#关于WUNTRACED&quot; class=&quot;headerlink&quot; title=&quot;关于WUNTRACED&quot;&gt;&lt;/a&gt;关于WUNTRACED&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;WUNTRACED告诉waitpid，如果子进程进入暂停状态，那么就立即返回。如果是被ptrace的子进程，&lt;strong&gt;那么即使不提供WUNTRACED参数，也会在子进程进入暂停状态的时候立即返回&lt;/strong&gt;。对于使用ptrace_cont运行的子进程，它会在3种情况下进入暂停状态：&lt;br&gt;①下一次系统调用；&lt;br&gt;②子进程退出&lt;br&gt;③&lt;strong&gt;子进程的执行发生错误。这里的0xb7f就表示子进程进入了暂停状态，且发送的错误信号为11(SIGSEGV)&lt;/strong&gt;，它表示试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。&lt;br&gt;那么什么时候会发生这种错误呢？显然，当子进程执行完注入的函数后，由于我们在前面设置了regs-&amp;gt;ARM_lr = 0，它就会返回到0地址处继续执行，这样就会产生SIGSEGV了！&lt;/p&gt;
&lt;p&gt;再说一下stat的值：高2字节用于表示导致子进程的退出或暂停状态信号值，低2字节表示子进程是退出(0x0)还是暂停(0x7f)状态。0xb7f就表示子进程为暂停状态，导致它暂停的信号量为11即sigsegv错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;if (regs-&amp;gt;ARM_pc &amp;amp; 1) {
    /* thumb */
    regs-&amp;gt;ARM_pc &amp;amp;= (~1u);
    regs-&amp;gt;ARM_cpsr |= CPSR_T_MASK;
} else {
    /* arm */
    regs-&amp;gt;ARM_cpsr &amp;amp;= ~CPSR_T_MASK;
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;指令使用目标地址值的bit[0]来确定目标地址的指令类型。bit[0]的值为1时，目标程序为Thumb指令；bit[0]值为0时，目标程序为ARM指令。&lt;br&gt;CPSR寄存器 第六位为T。T=0,代表为ARM指令，T为1,代表为Thumb指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;使用方法2：&quot;&gt;&lt;a href=&quot;#使用方法2：&quot; class=&quot;headerlink&quot; title=&quot;使用方法2：&quot;&gt;&lt;/a&gt;使用方法2：&lt;/h5&gt;&lt;p&gt;hook4开始要使用自己写的.so文件，所以把inject.c拷贝到jni文件下，然后编写Android.mk生成动态库文件。之后把libinject.so push 到/data/local/tmp下。之后运行target，再./hook4就可以进行劫持。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include $(CLEAR_VARS)
LOCAL_MODULE    := inject
LOCAL_SRC_FILES := inject.c
LOCAL_LDLIBS := -llog 
include $(BUILD_SHARED_LIBRARY)
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;hook4-动态加载so并执行自定义函数&quot;&gt;&lt;a href=&quot;#hook4-动态加载so并执行自定义函数&quot; class=&quot;headerlink&quot; title=&quot;#hook4: 动态加载so并执行自定义函数&quot;&gt;&lt;/a&gt;#hook4: 动态加载so并执行自定义函数&lt;/h5&gt;&lt;p&gt;保存当前寄存器的状态 -&amp;gt; 获取目标程序的mmap, dlopen, dlsym, dlclose 地址 -&amp;gt; 调用mmap分配一段内存空间用来保存参数信息 –&amp;gt; 调用dlopen加载so文件 -&amp;gt; 调用dlsym找到目标函数地址 -&amp;gt; 使用ptrace_call执行目标函数 -&amp;gt; 调用 dlclose 卸载so文件 -&amp;gt; 恢复寄存器的状态。&lt;/p&gt;
&lt;p&gt;这里mmap我一开始一脸懵逼，没学过操作系统真的很心累啊T T。大神之所以使用mmap，是为了共享参数。在target中新增一块内存地址，然后把各种函数参数都写到这块内存里面，之后进行调用就很方便了。&lt;/p&gt;
&lt;p&gt;这里我们不光使用printf()还使用了android debug的函数LOGD()用来输出调试结果。所以在编译时我们需要加上LOCAL_LDLIBS := -llog。&lt;/p&gt;
&lt;h5 id=&quot;hook5-函数挂钩实现native层hook&quot;&gt;&lt;a href=&quot;#hook5-函数挂钩实现native层hook&quot; class=&quot;headerlink&quot; title=&quot;#hook5: 函数挂钩实现native层hook&quot;&gt;&lt;/a&gt;#hook5: 函数挂钩实现native层hook&lt;/h5&gt;&lt;p&gt;其实就是android-inline-hook。&lt;br&gt;这里依旧要拷贝.so文件至手机。&lt;br&gt;基本思想是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先利用hook4调用我们自己写的libinject2.so中的mzhengHook函数。所以hook5.c和hook4.c没啥区别，就少了个dlclose进行卸载。所以主要逻辑代码都在libinject2.so文件。&lt;/li&gt;
&lt;li&gt;在MzhengHook中,将target的前三句指令换成我们自己的函数。然后其实该进程就推出了,target函数继续运行。&lt;/li&gt;
&lt;li&gt;然而target运行时，其实运行的是我们.so文件中自定义的函数，所以该函数可以劫持参数改变参数等。&lt;/li&gt;
&lt;li&gt;改变完后，调用hook_precall()恢复target为正常,然后让pc指向它。&lt;/li&gt;
&lt;li&gt;如果想一直劫持，就调用hook_postcall()再替换指令即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再来看hook_direct函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hook_direct(&amp;amp;eph,hookaddr,my_sevenWeapons);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在main中调用hook_direct函数，其中hookaddr是我们要劫持的函数的地址，也就是target中的函数，my_sevenWeapons是我们要替换成的我们自己编写的函数，它存在于so文件中。eph是一个结构体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct hook_t {
unsigned int jump[3];
unsigned int store[3];
unsigned int orig;
unsigned int patch;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先，因为我们要修改的是target中的代码段，这一般是不可写的，所以要用mprotect把区间改成可写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然android有ASLR，但并没有PIE，所以program image是固定在0x8000这个地址的，因此我们用mprotect()函数将整个target代码段变成RWX，这样我们就能修改函数入口处的代码了。是否修改成功可以通过cat /proc/[pid]/maps查看。&amp;lt;我测了一下，的确代码段是从8000-a000&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;//modify function entry    
h-&amp;gt;patch = (unsigned int)hookf;
h-&amp;gt;orig = addr;
h-&amp;gt;jump[0] = 0xe59ff000; // LDR pc, [pc, #0]
h-&amp;gt;jump[1] = h-&amp;gt;patch;
h-&amp;gt;jump[2] = h-&amp;gt;patch;
for (i = 0; i &amp;lt; 3; i++)
    h-&amp;gt;store[i] = ((int*)h-&amp;gt;orig)[i];
for (i = 0; i &amp;lt; 3; i++)
    ((int*)h-&amp;gt;orig)[i] = h-&amp;gt;jump[i];

//cacheflush    
hook_cacheflush((unsigned int)h-&amp;gt;orig, (unsigned int)h-&amp;gt;orig+sizeof(h-&amp;gt;jump));
return 1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;h-&amp;gt;patch 是我们自己写的函数地址。&lt;br&gt;h-&amp;gt;origin 是要hook的函数地址。&lt;br&gt;h-&amp;gt;jump&lt;br&gt;h-&amp;gt;store是将hook的函数的前三条语句保存下来。然后再把h-&amp;gt;jump放到h-&amp;gt;origin中，替换原函数的前三条语句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;随后我们需要确定目标函数的地址，这个有两种方法。如果目标程序本身没有被strip的话，那些symbol都是存在的，因此可以使用dlopen()和dlsym()等方法来获取目标函数地址。但很多情况，目标程序都会被strip，特别是可以直接运行的二进制文件默认都会被直接strip。比如target中的sevenWeapons()这个函数名会在编译的时候去掉，所以我们使用dlsym()的话是无法找到这个函数的。这时候我们就需要使用ida或者objdump来定位一下目标函数的地址。&lt;/p&gt;
&lt;p&gt;我们把目标函数的第一条指令修改为 LDR pc, [pc, #0]，这条指令的意思是跳转到PC指针所指的地址，由于pc寄存器读出的值实际上是当前指令地址加8，所以我们把后面两处指令都保存为hook函数的地址，这样的话，我们就能控制PC跳转到hook函数的地址了。&lt;br&gt;最后我们再调用hook_cacheflush()这个函数来刷新一下指令的缓存。因为虽然前面的操作修改了内存中的指令，但有可能被修改的指令已经被缓存起来了，再执行的话，CPU可能会优先执行缓存中的指令，使得修改的指令得不到执行。所以我们需要使用一个隐藏的系统调用来刷新一下缓存。(这不仅让我想起了路由器中的sleep函数T T)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;hook-from-古河&quot;&gt;&lt;a href=&quot;#hook-from-古河&quot; class=&quot;headerlink&quot; title=&quot;hook from  古河&quot;&gt;&lt;/a&gt;hook from  &lt;a href=&quot;http://bbs.pediy.com/showthread.php?t=141355&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;古河&lt;a&gt;&lt;/a&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;古河大大的hook其实就是前面的Hook4方法，利用自己写的.so文件的函数进行hook。当然一开始看他的代码非常心累，还用到了shellcode.s汇编来进行利用。其实说到底他只是把所有的函数地址都现在shellcode.s中定义好，然后在.so文件中作为外部变量进行引用，所有例如dlpen函数的实现也都放到汇编中罢了。&lt;/p&gt;
&lt;p&gt;主要关注&lt;strong&gt;inject_remote_process&lt;/strong&gt;函数。&lt;br&gt;例如，_dlopen_addr_s在shellcode.s中进行定义，然后在.so文件中extern进行外部引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code_length = (uint32_t)&amp;amp;_inject_end_s - (uint32_t)&amp;amp;_inject_start_s;//获取注入ShellCode代码指令的长度
dlopen_param1_ptr = local_code_ptr + code_length + 0x20;//本地为函数dlopen的第1个参数pathname变量申请内存空间
dlsym_param2_ptr = dlopen_param1_ptr + MAX_PATH;//本地为附加远程目标进程的寄存器状态值r0-r15(pc)的保存申请内存空间
saved_r0_pc_ptr = dlsym_param2_ptr + MAX_PATH;//本地为附加远程目标进程的寄存器状态值r0-r15(pc)的保存申请内存空间
inject_param_ptr = saved_r0_pc_ptr + MAX_PATH;  //本地为附加远程目标进程的Hook函数的参数inject_param_ptr申请内存空间 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;_inject_start_s为汇编中定义的shellcode开始符号&lt;/p&gt;
&lt;p&gt;所以古河的做法是，用mmap申请一段内存空间，构造方法是:&lt;br&gt;shellcode+dlpen_param1+dlsym_param2+saved_ro_pc+inject_param&lt;br&gt;把上述构造的内容放到mmap申请得到的内存空间中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* dlopen parameter 1: library name */
strcpy( dlopen_param1_ptr, library_path );
_dlopen_param1_s = REMOTE_ADDR( dlopen_param1_ptr, local_code_ptr, remote_code_ptr );
DEBUG_PRINT( &amp;quot;[+] _dlopen_param1_s: %x\n&amp;quot;, _dlopen_param1_s );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然前面得到的_dlopen_param1_ptr都是在本地shellcode开始的地址。还要转换为放到mmap申请得到的内存空间后的remote_addr。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;memcpy( &amp;amp;regs, &amp;amp;original_regs, sizeof(regs) );
regs.ARM_sp = (long)remote_code_ptr;//修改附加远程目标进程的sp寄存器的值为ShellCode的注入地址
regs.ARM_pc = (long)remote_code_ptr;//修改附加远程目标进程的pc寄存器的值为ShellCode的注入地址
ptrace_setregs( target_pid, &amp;amp;regs );
ptrace_detach( target_pid );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把sp ,pc都置为remote_code_ptr,然后detach使子进程开始运行shellcode。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;remote_code_ptr = map_base+0x3C00; // 这里就预留了0x3c00的空间
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里可以看到这句话的作用，因为sp也指向remote_addr，在注入代码之前一定得预留部分空间用作函数调用的栈空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/jinzhuojun/article/details/9900105&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的so注入(inject)和挂钩(hook) - For both x86 and arm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网上也有大神实现了不用shellcode.s，直接在.so调call来进行hook的，大神还区分了i386和arm平台，对i386平台我就不多写了。&lt;/p&gt;
&lt;h4 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://kiya.space/2015/12/21/hook-syscall/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hook - Android ARM下的的so注入&lt;a&gt;&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写android hook网上到处都是，但是作为菜鸟的我要不看不懂原理，要不就不知道到底应该怎么使用T T，这篇文章把网上所有的都整理了一下，给自己一点参考吧。&lt;/p&gt;
&lt;p&gt;所有代码详见github。&lt;/p&gt;
&lt;h3 id=&quot;Hook-From-蒸米&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="android逆向" scheme="http://yoursite.com/categories/android%E9%80%86%E5%90%91/"/>
    
    
      <category term="Hook" scheme="http://yoursite.com/tags/Hook/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
